// Generated by CoffeeScript 2.0.1
export default function (bits, abc) {
  var c, decode, encode, i, len, n, size;
  if (abc.length < 1 << bits) {
    throw Error("記号が足りません");
  }
  size = abc.length;
  decode = {};
  encode = abc;
  for (n = i = 0, len = abc.length; i < len; n = ++i) {
    c = abc[n];
    decode[c] = n;
  }
  return {
    toHex: function (code) {
      var base, buffer, j, limit, mask, str;
      str = "";
      base = 1;
      buffer = 0;
      bits = 4;
      limit = 1 << bits;
      mask = limit - 1;
      for (j = code.length - 1; j >= 0; j += -1) {
        c = code[j];
        n = decode[c];
        if (n == null) {
          console.error(`decode error on ${c}`);
          return null;
        }
        buffer += n * base;
        base *= size;
        while (base >= limit) {
          str = (buffer & mask).toString(16) + str;
          buffer >>= bits;
          base >>= bits;
        }
      }
      return str;
    },
    byNumber: function (size, buffer) {
      var code, index, j, mask, ref, ref1, str;
      mask = (1 << bits) - 1;
      str = "";
      for (index = j = ref = size * 8, ref1 = -bits; ref1 > 0 ? j <= 0 : j >= 0; index = j += ref1) {
        n = index - bits;
        switch (false) {
          case !(n > 31 - bits):
            code = 0;
            break;
          //          console.warn [n]
          case !(n > 0):
            code = (buffer & mask << n) >> n;
            break;
          //          console.warn [n, [ buffer, (mask << n), code].map (it)-> it.toString(2)]
          case n !== 0:
            code = buffer & mask;
            break;
          //          console.warn [n, [ buffer, mask, code].map (it)-> it.toString(2)]
          case !(0 > n):
            code = (buffer & mask >> -n) << -n;
        }
        //          console.warn [n, [ buffer, (mask >> -n), code].map (it)-> it.toString(2)]
        str += encode[code];
      }
      return str;
    }
  };
};